<!DOCTYPE html>
<html>
    <head>
<!--include head.txt -->
        <title>
            11. Customizing Input and Output
        </title>
<!--include googleAnalyticsScript.txt -->
    </head>

    <body>
        <div class="wrapper">
<!--include navbar.txt -->
            <div id="content">
                <h1>
                    11. Customizing Input and Output
                </h1>
                <details>
                    <summary class="sum1">
                    11.1 Regularity and irregularity
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    The iostream library which is the input/output part of the
                    ISO C++ standard library. This Library provides a unified
                    and extensible for I/O of text. In this chapter we will 
                    learn number of ways in which we can tailor I/O to our
                    needs
                    </p>
                </details>
                <details>
                    <summary class="sum1">
                    11.2 Output formatting
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    People care a lot about the minor details of output. Our
                    aim as a programmer is to keep output as clear and close 
                    to user's expectation as possible
                    </p>
                    <details>
                        <summary class="sum2">
                        11.2.1 Integer output
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        Integer values can be output as octal, decimal, and
                        hexadecimal. Most output uses decimal. Below code
                        represents output 1234 (decimal) to decimal,
                        hexadecimal, and octal:
                        </p>
                        <code>
                        <pre>
                        cout &lt;&lt; 1234 &lt;&lt; "\t(decimal)\n"
                            &lt;&lt; hex &lt;&lt; 1234 &lt;&lt; "\t(hexadecimal)\n"
                            &lt;&lt; oct &lt;&lt; 1234 &lt;&lt; "\t(octal)\n";
                        </pre>
                        </code>
                        <p>
                        Output for this is:
                        </p>
                        <code>
                        <pre>
                        1234 (decimal)
                        4d2 (hexadecimal)
                        2322 (octal)
                        </pre>
                        </code>
                    </details>
                    <details>
                        <summary class="sum2">
                        11.2.2 Integer input
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        By default, &gt;&gt; assumes that numbers use the decimal
                        notation, but it can also read hexadecimal or octal 
                        integers:
                        </p>
                        <code>
                        <pre>
                        int a;
                        int b;
                        int c;
                        int d;
                        cin &gt;&gt; a &gt;&gt; hex &gt;&gt; b &gt;&gt; oct &gt;&gt; c &gt;&gt; d;
                        cout &lt;&lt; a &lt;&lt; '\t' &lt;&lt; b &lt;&lt; '\t' &lt;&lt; c &lt;&lt; '\t' &lt;&lt; d &lt;&lt; '\n';
                        </pre>
                        </code>
                        <p>
                        If you type in:<br/>
                        <code>
                        1234 4d2 2322 2322<br/>
                        </code>
                        this will print:<br/>
                        <code>
                        1234 1234 1234 1234
                        </code>
                        </p>
                    </details>
                    <details>
                        <summary class="sum2">
                        11.2.3 Floating-point output
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        This is very important in case you are dealing with
                        scientific computation. These are handled using
                        <code>iostream</code> manipulator in a manner very
                        similar to that of integer values:
                        </p>
                        <code>
                        <pre> 
                        cout &lt;&lt; 1234.56789 &lt;&lt; "\t\t(defaultfloat)\n"   // \t\t to line up columns
                            &lt;&lt; fixed &lt;&lt; 1234.56789 &lt;&lt; "\t(fixed)\n"
                            &lt;&lt; scientific &lt;&lt; 1234.56789 &lt;&lt; "\t(scientific)\n"; 
                        </pre>
                        </code>
                        <p>
                        This prints:
                        </p>
                        <code>
                        <pre>
                        1234.57         (general)
                        1234.567890     (fixed)
                        1.234568e+003   (scientific)
                        </pre>
                        </code>
                    </details>
                    <details>
                        <summary class="sum2">
                        11.2.4 Precision
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        By default the precision for floating point numbers is
                        six total digits using the <code>defaultfloat</code>
                        format. The chooses the most appropriate format and the
                        number is rounded to give the best approximation that
                        can be printed using only six digits.
                        </p>
                        <p>
                        A programmer can set the precision using the
                        manipulator setprecision(). For example:
                        </p>
                        <code>
                        <pre>
                        cout &lt;&lt; 1234.56789 &lt;&lt; '\t'
                            &lt;&lt; fixed &lt;&lt; 1234.56789 &lt;&lt; '\t'
                            &lt;&lt; scientific &lt;&lt; 1234.56789 &lt;&lt; '\n';
                        cout &lt;&lt; defaultfloat &lt;&lt; setprecision(5)
                            &lt;&lt; 1234.56789 &lt;&lt; '\t'
                            &lt;&lt; fixed &lt;&lt; 1234.56789 &lt;&lt; '\t'
                            &lt;&lt; scientific &lt;&lt; 1234.56789 &lt;&lt; '\n';
                        cout &lt;&lt; defaultfloat &lt;&lt; setprecision(8)
                            &lt;&lt; 1234.56789 &lt;&lt; '\t'
                            &lt;&lt; fixed &lt;&lt; 1234.56789 &lt;&lt; '\t'
                            &lt;&lt; scientific &lt;&lt; 1234.56789 &lt;&lt; '\n';
                        </pre>
                        </code>
                        <p>
                        This prints (note the rounding):
                        </p>
                        <code>
                        <pre>
                        1234.57     1234.567890     1.234568e+003
                        1234.6 1234.56789   1.23457e+003
                        1234.5679   1234.56789000   1.23456789e+003
                        </pre>
                        </code>
                    </details>
                    <details>
                        <summary class="sum2">
                        11.2.5 Fields
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        Using scientific and fixed formats, a programmer can
                        control exactly how much space a value takes up on output. 
                        That’s clearly useful for printing tables, etc.
                        “set field width” manipulator <code>setw()</code>
                        can be used to specify exactly how many character 
                        positions an integer value or string value will occupy.
                        Example:
                        </p>
                        <code>
                        <pre>
                        cout &lt;&lt; 123456
                            &lt;&lt;'|'&lt;&lt; setw(4) &lt;&lt; 123456 &lt;&lt; '|'
                            &lt;&lt; setw(8) &lt;&lt; 123456 &lt;&lt; '|'
                            &lt;&lt; 123456 &lt;&lt; "|\n";
                        </pre>
                        </code>
                        <p>
                        This prints:
                        </p>
                        <code>
                        <pre>
                        123456|123456| 123456|123456|
                        </pre>
                        </code>
                    </details>
                </details>
                <details>
                    <summary class="sum1">
                    11.3 File opening and positioning
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    A file is is an abstraction of what the operating system
                    provides as per C++. A file is sequence of bytes numbered
                    from 0 upwards.The question is how to access these bytes.
                    The simplest example of this is that if we open an
                    <code>istream</code> for a file, we can read from the 
                    file, whereas if we open a file with an <code>ostream</code>, 
                    we can write to it.
                    </p>
                    <details>
                        <summary class="sum2">
                        11.3.1 File open modes
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        A file can be opened in several modes. By default,
                        <code> ifstream</code> opens it for reading and
                        <code>ofstream</code> opens for writing. Thes take care
                        of the most common needs but there are several other 
                        alternatives given in the book.A file mode is
                        optionally specified after the name of the file. For example: 
                        </p>
                        <code>
                        <pre>
                        ofstream of1 {name1};   //defaults to ios_base::out
                        ifstream if1 {name2};   //defaults to ios_base::in
                        
                        ofstream ofs {name, ios_base::app}; //ofstreams by default include
                                                            //io_base::out
                        fstream fs {"myfile",ios_base::in|ios_base::out};//both in and out
                        </pre>
                        </code>
                    </details>
                    <details>
                        <summary class="sum2">
                        11.3.2 Binary files
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        
                        </p>
                    </details>
                    <details>
                        <summary class="sum2">
                        11.3.3 Positioning in files
                        </summary>
                        <figure>
                            <img src="" width="40%">
                            <figcaption>
                            </figcaption>
                        </figure>
                        <p>
                        </p>
                    </details>
                </details>
                <details>
                    <summary class="sum1">
                    11.4 String streams
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    A <code>string</code> can be used as a source of an
                    <code>istream</code> or the target for an 
                    <code>ostream</code>
                    .An <code>istream</code> that reads from a
                    <code>string</code> is called
                    an <code>istringstream</code> and an <code>ostream</code> 
                    that stores characters written to it in a
                    <code>string</code> is called an <code>ostringstream</code>.
                    We can use an <code>istringstream</code> is 
                    useful for extracting
                    numeric values from a<code> string</code>:
                    </p>
                    <code>
                    <pre>
                    double str_to_double(string s)
                        // if possible, convert characters in s to floating-point value
                    {
                        istringstream is {s};      // make a stream so that we can read from s
                        double d;
                        is &gt;&gt; d;
                        if (!is) error("double format error: ",s);
                        return d;
                    }
                    double d1 = str_to_double("12.4");
                    double d2 = str_to_double("1.34e–3");
                    double d3 = str_to_double("twelve point three");
                    </pre> 
                    </code>
                </details>
                <details>
                    <summary class="sum1">
                    11.5 Line-oriented input
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    If we want to read everything on a line at once and want to
                    decide the format later. This can be done using the
                    function <code>getline()</code>. For example:
                    </p>
                    <code>
                    <pre>
                    string name;
                    getline(cin,name);      // input: Dennis Ritchie
                    cout &lt;&lt; name &lt;&lt; '\n';// output: Dennis Ritchie
                    </pre> 
                    </code>
                    <p>
                    &gt;&gt; reads only until it encounters whitespace. If we
                    use &gt;&gt; instead of <code>getline()</code> the output
                    will be 'Dennis'.
                    </p>
                </details>
                <details>
                    <summary class="sum1">
                    11.6 Character classification
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    Sometimes we go down to a level of abstraction and read
                    individual characters. This is certainly more work but when
                    we do this, we have a full control over what we are
                    doing.Consider tokenizing this expression:
                    <code>1+4*x&lt;=y/z*5</code> to be separated 
                    into the eleven tokens.
                    </p>
                    <p>
                    We could use &gt;&gt; to read numbers. but trying to read
                    identifiers as strings would cause <code>x&lt;=y</code> to
                    to be read as one string. Similarly it will read
                    <code>z*</code> as one string.So, instead we can write
                    something like this:
                    </p>
                    <code>
                    <pre> 
for (char ch; cin.get(ch); ) {
    if (isspace(ch)) {  // if ch is whitespace
        // do nothing (i.e., skip whitespace)
    }
    if (isdigit(ch)) {
        // read a number
    }
    else if (isalpha(ch)) {
        // read an identifier
    }
    else {
        // deal with operators
    }
}  
                    </pre>
                    </code>
                </details>
                <details>
                    <summary class="sum1">
                    11.7 Using nonstandard separators
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    </p>
                </details>
                <details>
                    <summary class="sum1">
                    11.8 And there is so much more
                    </summary>
                    <figure>
                        <img src="" width="40%">
                        <figcaption>
                        </figcaption>
                    </figure>
                    <p>
                    The details of I/O seem infinite. They probably are, since
                    they are limited only by human inventiveness and capriciousness. For
                    example, we have not considered the complexity implied by natural languages.
                    </p>
                </details>

                <details>
                    <summary class="sum1">
                    Test Yourself!
                    </summary>
                    <figure>
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2e/Exams_in_Jaura%2C_India.jpg/560px-Exams_in_Jaura%2C_India.jpg"
                        width="20%">
                        <figcaption>
                        </figcaption>
                    </figure>
<!-- Include the test material here! -->
                </details>

                <details>
                    <summary class="sum1">
                    Drill
                    </summary>
                    <figure>
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/Queens.guard.buck.palace.arp.jpg/600px-Queens.guard.buck.palace.arp.jpg"
                        width="20%">
                        <figcaption>
                        </figcaption>
                    </figure>

                    <ol>
                    </ol>
                </details>
            </div>
        </div>

    </body>
</html>
